## 가상 메모리

크기가 다른 물리 메모리에서 일관되게 프로세스를 실행할 수 있도록 하는 기술이다. 프로세스에 커다란 메모리 공간을 제공하여 크기를 신경 쓰지 않고 메모리를 사용할 수 있게 해준다.

또한, 프로세스 전체가 메모리 내에 올라오지 않더라도 실행할 수 있도록 한다.

### 가상 메모리의 크기

가상 메모리에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 물리 메모리와 스왑 영역을 합한 크기이다.

**스왑 영역**은 하드디스크에 존재하지만 메모리 관리자가 관리하는 영역이며 가상 메모리의 구성 요소 중 하나이다.

물리 메모리가 꽉 차면 일부 프로세스를 스왑 영역으로 보내고(**스왑아웃**), 몇 개의 프로세스가 작업을 마치면 스왑 영역에 있는 프로세스를 메모리로 가져온다(**스왑인**).

**※ DAT(Dynamic Address Translation):** 동적 주소 변환. 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리 주소로 변환하는 작업.

### 가상 메모리의 메모리 분할 방식

가상 메모리 시스템은 운영체제 영역을 제외한 나머지 메모리 영역을 일정한 크기로 나누어 일반 프로세스에 할당한다. 메모리 분할 방식은 크게 **세그먼테이션**과 **페이징**으로 나뉜다.

**세그먼테이션**: 가변 분할 방식

**페이징**: 고정 분할 방식

두 기법의 단점을 보완한 **세그먼테이션-페이징** 혼용 기법을 주로 사용한다. 사용자 입장에선 세그먼테이션 기법, 메모리 관리자 입장에선 페이징 기법을 사용.

## 요구 페이징

가상 메모리 시스템에서 필요한 프로그램만 메모리에 적재하는 기법

### 요구 페이징의 개요

운영체제는 꼭 필요한 프로세스만 메모리에 유지한다. 프로세스 전체를 메모리에 올리지 않고 필요한 모듈만 메모리에 올려 실행하고 나머지 모듈은 필요하다고 판단될 때 메모리에 불러온다. 그 이유는?

- **메모리를 효율적으로 관리**하기 위해서이다. 메모리가 꽉 차면 관리하기 어려우므로 가급적 적은 양의 프로세스만 유지한다.
- **응답 속도 향상**을 위해서이다. 용량이 큰 프로세스를 전부 메모리에 가져와 실행하면 응답이 늦어질 수 있다.

예를 들어 포토샵 같은 대형 프로그램을 실행하면 메모리에는 포토샵의 본프로그램만 올리고 피부 보정 필터나 노이즈 제거 필터 같은 외부 필터는 사용할 때 메모리로 가져온다.

### 페이지 테이블 엔트리 구조

PTE는 페이지 테이블의 한 행을 말한다.

```
+-------------+---+---+---+---+---+---+-------------+
| 페이지 번호 | a | m | v | r | w | x | 프레임 번호 |
+-------------+---+---+---+---+---+---+-------------+
```

- **접근 비트(access or reference bit):** 페이지가 메모리에 올라온 후 사용한 적이 있는지 알려주는 비트
- **변경 비트(modified or dirty bit):** 페이지가 메모리에 올라온 후 데이터의 변경이 있었는지 알려주는 비트
- **유효 비트(valid or present bit):** 페이지가 실제 메모리에 있는지를 나타내는 비트. 스왑 영역에 있으면 1로 나타냄.
- **읽기, 쓰기, 실행 비트(read bit, write bit, execute bit):** 페이지에 대한 읽기 권한, 쓰기 권한, 실행 권한을 나타내는 비트. 합쳐서 rights bits라고도 부름.

## 페이지 교체 알고리즘

페이지 부재가 발생하여 스왑 영역에서 페이지를 메모리로 가져오는데 메모리가 꽉 찼다면 메모리에 있는 페이지를 스왑 영역으로 내보내야 한다. 이 때 희생될(victim) 페이지를 페이지 교체 알고리즘으로 고른다.

### 지역성

페이지 교체 알고리즘이 쫓아낼 페이지를 찾을 때는 지역성을 바탕으로 한다.

- **공간의 지역성**: 현재 위치에서 가까운 데이터에 접근할 확률이 높다고 봄
- **시간의 지역성**: 현재를 기준으로 가장 가까운 시간에 접근한 데이터가 더 먼 시간에 접근한 데이터보다 사용될 확률이 높다고 봄
- **순차적 지역성**: 여러 작업이 순서대로 진행되는 경향이 있다는 것을 의미. 공간의 지역성의 특별한 경우라고 보기도 한다.

### 페이지 교체 알고리즘 종류

| 종류               | 알고리즘  | 특징                                                                 |
|--------------------|-----------|----------------------------------------------------------------------|
| 간단한 알고리즘    | 무작위    | 무작위로 대상 페이지를 선정하여 스왑 영역으로 보낸다.                |
|                    | FIFO      | 처음 메모리에 올라온 페이지를 스왑 영역으로 보낸다.                  |
| 이론적 알고리즘    | 최적      | 미래의 접근 패턴을 보고 대상 페이지를 선정하여 스왑 영역으로 보낸다. |
| 최적 근접 알고리즘 | LRU       | 시간적으로 멀리 떨어진 페이지를 스왑 영역으로 보낸다.                |
|                    | LFU       | 사용 빈도가 적은 페이지를 스왑 영역으로 보낸다.                      |
|                    | NUR       | 최근에 사용한 적이 없는 페이지를 스왑 영역으로 보낸다.               |
|                    | FIFO 변형 | FIFO 알고리즘을 변형하여 성능을 높인다.                              |

#### 무작위 페이지 교체 알고리즘(random page relacement algorithm)

가장 간단하게 구현할 수 있는 방식. 쫓아낼 대상 페이지를 특별한 로직 없이 무작위로 선정한다. 성능이 좋지 않아 거의 사용되지 않는다.

#### FIFO 페이지 교체 알고리즘

선입선출 페이지 교체 알고리즘이라고 한다. 시간상으로 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정하여 쫓아낸다. (큐로 구현)

#### 최적 페이지 교체 알고리즘(optimal page replacement algorithm)

 앞으로 가장 오랫동안 사용하지 않을 페이지를 대상 페이지로 선정. 미래를 알 수 없어 실제 구현 불가능.

#### LRU 페이지 교체 알고리즘(Least Recently Used)

가장 오랫동안 사용되지 않은 페이지를 대상 페이지로 선정. 일반적으로 FIFO 보다 우수하고 최적 페이지 교체 알고리즘보다 조금 떨어지는 것으로 알려져 있다.

시간을 기준으로 구현할 수 있으며 카운터나 참조 비트를 이용하는 방법도 있다. 그러나 시간에 기반한 구현과 카운터에 기반한 구현은 모두 숫자를 기록하기 위한 추가적인 메모리 공간을 필요로 한다.

##### 참조 비트 시프트 방식

한바이트(8bits)를 사용. 페이지에 접근할 때 맨 앞 비트를 1로 바꾼다. 매 접근 시 모든 참조 비트를 오른쪽으로 한 칸씩 이동시킨다. 대상 페이지를 선정할 필요가 있으면 참조 비트 중 가장 작은 값을 갖고 있는 페이지를 선정한다.

한 바이트긴 하지만 이 역시 적지 않은 메모리 공간을 사용한다.

#### LFU 페이지 교체 알고리즘(Least Frequently Used)

가장 적게 사용된 페이지를 대상 페이지로 선정. 이 역시 접근 횟수를 표시하는 추가 메모리 공간이 필요하다.

#### NUR 페이지 교체 알고리즘(Not Used Recently)

LRU, LFU와 성능이 비슷하면서 불필요한 공간 낭비 문제를 해결한 알고리즘. 일일이 접근 시간이나 빈도를 정확하게 기록하지 말고 비슷한 횟수로 접근한 페이지가 두 개 있으면 어떤 페이지를 쫓아내도 상관없다고 가정한다.

참조 비트와 변경 비트 두 가지 비트를 사용한다. (참조 비트, 변경 비트)

(0, 0), (0, 1), (1, 0), (1, 1) 순으로 대상 페이지를 선정한다. 만약 모든 페이지가 (1, 1)이 되면 모두 (0, 0)으로 초기화 한다.

LRU, LFU와 비슷한 성능이지만 메모리를 아낄 수 있기 때문에 가장 많이 사용되는 알고리즘이다.

#### 2차 기회 페이지 교체 알고리즘(FIFO 변형)

FIFO와 마찬가지로 큐를 사용하지만 페이지 접근이 성공하는 경우 해당 페이지를 큐의 맨 뒤로 이동시켜 기회를 한번 더 준다.

FIFO 보다 성능이 높지만 LRU, LFU, NUR 보단 낮다.

#### 시계 알고리즘

원형 큐를 사용하는 방식이다. 대상 페이지를 가리키는 포인터를 사용하며 페이지가 쫓겨나면 포인터를 이동시킨다.