# 무결성 제약조건 

- 무결성 : 데이터에 결함이 없는 상태, 즉 데이터가 정확하고 유효하게 유지되는 상태이다. 
- 무결성 제약조건의 주요 목적은 데이터베이스에 저장된 데이터의 무결성을 보장하고 데이터베이스의 상태를 일관되게 유지하는 것이다.
- 데이터베이스가 삽입, 삭제, 수정 연산으로 상태가 변하더라도 무결성 제약조건은 반드시 지켜야 한다.
- 관계 데이터 모델이 기본으로 포함하고 있는 무결성 제약조건에는 개체 무결성 제약조건과 참조 무결성 제약조건으로 나뉜다. 데이터베이스의 상태를 일관성 있게 유지하기 위해서는 두가지 모두 만족시켜야 한다.
  - 개체 무결성 제약조건 : 기본키를 구성하는 모든 속성은 널(NULL) 값을 가질 수 없다.
  - 참조 무결성 제약조건 : 외래키는 참조할 수 없는 값을 가질 수 없다.


### 1) 개체 무결성 제약조건 (entity integrity constraint) 

- __릴레이션에서 기본키를 구성하는 모든 속성은 널(NULL)값이나 중복값을 가질 수 없다.__
- 관계 데이터 모델에서는 릴레이션에 포함되어 있는 튜플들을 유일하게 구별해주고 각 투플에 쉽게 접근할 수 있도록 릴레이션마다 기본 키를 정의한다. 그런데 기본 키를 구성하는 속성 전체나 일부가 널 값이 되면 튜플의 유일성을 판단할 수 없어 기본키의 본래 목적을 상실하게 된다.
- 개체 무결성 제약조건을 만족시키려면 새로운 튜플이 삽입되는 연산과 기존 투플의 기본키 속성 값이 변경되는 연산이 발생할 때 기본키에 널 값이 포함되는 상황에서는 연산의 수행을 거부하면 된다. 
- ex. <학생> 릴레이션에서 '학번'이 기본키로 정의되면 튜플을 추가할 때 '주민번호'나 '성명'필드에는 값을 입력하지 않아도 되지만 '학번' 속성에는 반드시 값을 입력해야 한다. 또한 '학번' 속성에는 이미 한번 입력한 속성값을 중복하여 입력 할 수 없다.



### 2) 참조 무결성 제약조건 (reference integrity constraint)
- 외래키 값은 참조 릴레이션의 기본키 값과 동일해야 한다. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다.
- 외래키는 다른 릴레이션의 기본 키를 참조하는 속성이고 릴레이션간의 관계를 표현하는 역할을 한다. 그런데 외래키가 자신이 참조하는 릴레이션의 기본키와 상관이 없는 값을 가지게 되면 두 릴레이션을 연관시킬 수 없으므로 외래키 본래의 의미가 없어진다. 그러므로 외래키는 자신이 참조하는 릴레이션에 기본키값으로 존재하는 값, 즉 *참조 가능한 값*만 가져야 한다.
- ex. <수강> 릴레이션 '학번' 속성에는 <학생> 릴레이션의 '학번' 속성에 없는 값은 입력할 수 없다.
- Q. 외래키가 널 값인 경우는 무조건 참조 무결성 제약조건을 위반했다고 볼 수 있을까? 
  - 그렇지만은 않다. 주문고객 속성 값이 널이라는 것은 주문한 고객이 누구인지 모를 뿐, 고객 릴레이션에 존재하지 않는 고객이 주문한 것으로 판단하기는 어렵다. 그러므로 참조 무결성 제약조건을 만족시키려면 외래키가 참조 가능한 값만 가져야 하지만, 널 값을 가진다고 해서 참조 무결성 제약조건을 위반한 것으로 판단해서는 안된다.





<br></br>
# 트랜잭션 (Transaction)

- 트랜잭션은 다수 사용자가 데이터베이스를 동시에 접근하도록 허용하면서 데이터 베이스가 일관성을 유지하게 하는 기술
- 데이터베이스의 __회복__ 과 __동시성 제어__ 를 가능하게 해 데이터베이스가 일관된 상태를 유지하게 한다. 🌟
  - 동시성 제어(Concurency control) : 여러 사용자가 데이터베이스를 동시에 공유할 수 있도록 여러 트랜잭션이 동시에 수행될수 있게 함. *여러 트랜잭션이 차례로 번갈아 수행되는 인터리빙(interleaving)방식 채용*
  - 회복 : 데이터베이스에 장애 발생시 장애 발생 전 상태로 복구시키는 것.
- 트랜잭션은 모두 실행되거나 실행되지 않거나(all or nothing). 즉, 데이터 작업시에 문제가 생기면, 데이터 작업을 하기 이전 시점으로 모든 데이터를 원상 복구한다.
- 예시
  - ![img](https://github.com/workhardslave/cs-study/blob/main/Database/img/Integrity&Transaction0.png?raw=true)
  - ![img](https://github.com/workhardslave/cs-study/blob/main/Database/img/Integrity&Transaction1.png?raw=true)

<br></br>
### 트랜잭션의 특성

데이터베이스 트랜잭션이 안전한 수행을 보장하기 위해 네가지 특성 __원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 내구성(Durability)__ 을 만족해야 한다. 
앞글자를 따 ACID 특성이라고도 한다.


#### 1) 원자성(Atomicity) 🌟
트랜잭션을 구성하는 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야 한다는 방식. 만약 트랜잭션을 수행하다가 장애가 발생하여 작업을 완료하지 못했다면, 지금까지 실행한 연산 처리를 모두 취소하고 데이터베이스를 트랜잭션 작업 전의 상태로 되돌려 원자성을 보장해야 한다. 트랜잭션을 원자성을 보장하면 트랜잭션을 구성하는 연산 중 일부만 처리한 결과를 데이터베이스에 반영하는 일이 없게 된다.

#### 2) 일관성(Consistency) 
트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관된 상태를 유지해야 한다. 즉, 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태였다면 트랜잭션의 수행이 완료된 후 결과를 반영한 데이터베이스도 또 다른 일관된 상태가 되어야 한다. 트랜잭션이 수행되는 과정에서는 데이터베이스가 일시적으로 일관된 상태가 아닐 수 있지만, 트랜잭션의 수행이 성공적으로 완료된 후에는 데이터베이스가 일관된 상태를 유지해야 한다.

#### 3) 격리성(Isolation) 
현재 수행중인 트랜잭션이 완료될 때 까지 트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션들이 접근할 수 없음을 의미한다. 일반적으로 데이터베이스 시스템에서는 여러 트랜잭션이 동시에 수행되지만 각 트랜잭션이 독립적으로 수행 될 수 있도록 다른 트랜잭션의 중간 연산 결과에 서로 접근하지 못하게 한다.
이를 위해서는 트랜잭션의 수행 과정에서 생성되는 중간 연산의 결과에 다른 트랜잭션이 접근할 수 없도록 하여 트랜잭션의 격리성을 보장해야 한다. 
즉, 순서대로 하나씩 수행되는 것과 같은 결과를 얻을 수 있도록 제어하는 기능이 필요하다. 

#### 4) 지속성(durability) 
트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행 결과는 어떠한 경우에도 손실되지 않고 영구적이어야 한다. 즉, 시스템에 장애가 발생하더라도 트랜잭션 작업 결과는 없어지지 않고 데이터베이스에 그대로 남아있어야 한다.


<br></br>
### DBMS 
- 다수의 컴퓨터 사용자들이 컴퓨터에 수록 된 수 많은 자료들을 쉽고 빠르게 추가, 수정, 삭제 할 수 있도록 해주는 시스템
- 데이터베이스 내의 정보를 검색하거나 정보를 저장하기 편리하고 효율적인 환경을 제공하는 것이 목적

#### RDBMS(Relational DataBase Management System) 🌟
- 관계형 데이터베이스 시스템으로 가장 주류로 사용됨.
- SQL(Structured Query Language) : 관계형 데이터베이스를 이용하기 위한 표준 언어
- 대표적인 RDBMS에는 Oracle, MS SQL Server, MySQL 등이 있다.
- 특징
  - 모든 데이터를 로우(Row: 행, 줄)와 컬럼(Column: 열, 칸)의 2차원으로 표현
  - 어떤 상황에서도 데이터 무결성을 보장한다. 즉, __안정성__ 과 __일관성__ 에 강점을 보인다.
  - 트랜잭션(All or Nothing) 처리 가능 *NoSQL은 트랜잭션을 지원하지 않음.*
  - 단, 수평적 확장이 어렵다는 단점이 존재

<br></br>
### 트랜잭션의 연산
트랜잭션 연산은 작업 완료를 의미하는 commit과 작업 취소를 의미하는 rollback이 주로 사용된다.

- commit : 트랜잭션에서 변경하려는 내용이 데이터베이스에 완전하게 반영되는 연산.
- rollback : 트랜잭션이 갱신한 사항을 트랜잭션이 수행되기 전의 상태로 되돌리는 연산. 트랜잭션에서 변경 내용이 데이터베이스에 일부만 반영된 경우에는 원자성을 보장하기 위해 되돌려야 함.

<br></br>
### 동시성 제어(Concurency control)
  - 여러 사용자가 데이터베이스를 동시에 공유할 수 있도록 여러 트랜잭션이 동시에 수행될수 있게 함.
  - 단, 동시에 데이터의 무결성을 유지해야 함.
#### 로킹(Locking)
  - 동시에 수행되는 트랜잭션이 동일 데이터에 접근하지 못하도록 lock/unlock 연산으로 제어하는 것
  - 한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 마칠 때 까지 해당 데이터에 다른 트랜잭션이 접근하지 못하도록 상호 배재하여 직렬 가능성을 보장하는 것.
  - lock 연산
    - 공용 lock
      - 데이터에 대한 사용권을 여러 트랜잭션이 함께 가질 수 있음. 
      - 트랜잭션이 데이터에 대해 공용 lock을 수행하면, 해당 데이터에 read연산을 수행할 수 있지만 write연산은 수행할 수 없음
      - 해당 데이터에 대해 다른 트랜잭션도 공용 lock 연산을 동시에 실행할 수 있음
      - 즉, 데이터에 대한 사용권을 여러 트랜잭션이 함께 가질 수 있음
    - 전용 lock
      - 트랜잭션이 데이터에 전용 lock을 실행하면 해당 데이터에 대해 read, write연산 모두 할 수 있음.
      - 그러나 해당 데이터에 대해 다른 트랜잭션은 어떠한 lock 연산도 실행할 수 없음
      - 즉, 전용 lock 연산을 실행한 트랜잭션만 해당 데이터에 대한 독점권을 
#### 2단계 로킹 프로토콜
  - lock을 요청하는 것과 lock을 해제하는 것이 2단계로 이루어 진다는 규약
  - 2단계 로킹 프로토콜을 따르기 위해서는 모든 트랜잭션이 lock/unlock을 다음과 같이 수행한다
     - 확장 단계 : 트랜잭션이 lock만 수행할 수 있고, unlock은 수행할 수 없음
     - 축소 단계 : 트랜잭션이 unlock만 수행할 수 있고, lock은 수행할 수 없음
  - 즉, lock 확장 단계가 지난 후에 수축 단계를 수행할 수 있음.
  - 교착상태(Deadlock) 발생 가능
     - 교착상태 : 트랜잭션이 상대가 독점한 데이터에 unlock 연산이 실행되기 서로 기다리면서 트랜잭션 수행을 중단하고 있는 상태. 
     - 교착상태에 빠지면 트랜잭션은 더이상 수행되지 못하고 상대 트랜잭션의 unlock을 무한히 기다림
     - 예를들어, 트랜잭션 T1이 T2가 lock한 데이터 X에 접근하기 위해 T2가 unlock을 수행하기를 기다리고, T2는 T1이 lock한 데이터 Y에 접근하기 위해 T1이 unlock을 수행하기를 기다리면 교착상태에 빠지게 된다.




<br></br>
>Reference</br>
>김연희, 『데이터베이스 개론』, 한빛아카데미(2021), 무결성 제약조건 & 트랜잭션</br>
>https://itwiki.kr/w/트랜잭션</br>
>https://namu.wiki/w/데이터베이스?from=RDBMS</br>
>https://91ms.tistory.com/2</br>
>https://slidesplayer.org/slide/15480449/</br>
>https://limkydev.tistory.com/161</br>
